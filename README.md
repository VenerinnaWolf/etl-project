# Проектное задание для учебного центра Neoflex
## Результаты работы
Видео с демонстрацией работы и комментариями по каждому из пунктов задания можно посмотреть по <a href="https://drive.google.com/drive/folders/1Ca9IWXR3dJkluCv96hHp9469wI8MWOVD?usp=sharing">этой ссылке</a>

Также каждый из пунктов задания представлен в [релизах](https://github.com/VenerinnaWolf/etl-project/releases) под соответствующим тегом.

# Задание 1
В некотором банке внедрили новую frontend-систему для работы с клиентами, а также обновили и саму базу данных. Большая часть данных была успешно перенесена из старых БД в одну новую централизованную БД. Но в момент переключения со старой системы на новую возникли непредвиденные проблемы в ETL-процессе, небольшой период (конец 2017 - начало 2018 года) так и остался в старой базе. Старую базу отключили, а не выгруженные данные сохранили в csv-файлы. 

Недавно банку потребовалось построить отчёт по 101 форме. Те данные что остались в csv-файлах тоже нужны. Загрузить их в новую БД не получится из-за архитектурных и управленческих сложностей, нужно рассчитать витрину отдельно. Но для этого сначала нужно загрузить исходные данные из csv-файлов в детальный слой (DS) хранилища в СУБД PostgreSQL.

## Задание 1.1
Разработать ETL-процесс для загрузки «банковских» данных из csv-файлов в соответствующие таблицы СУБД PostgreSQL слоя «DS». Покрыть данный процесс логированием этапов работы и всевозможной дополнительной статистикой (на ваше усмотрение). Обратите внимание, что в разных файлах может быть разный формат даты, это необходимо учитывать при загрузке.

### Исходные данные:
Файл «Структура таблиц.docx» – содержит описание и поможет создать таблицы в детальном слое DS

Краткое описание данных таблиц:

- Таблицы DS.MD_ACCOUNT_D, DS.MD_CURRENCY_D и DS.MD_EXCHANGE_RATE_D содержат информацию о счетах, валютах и курсах валют соответственно. В данных таблицах есть поля data_actual_date и data_actual_end_date, по которым можно определить какие именно записи актуальны в нужную дату. Идентификаторы записей имеют окончание «_rk» (например, account_rk – идентификатор счета).
- Таблица DS.MD_LEDGER_ACCOUNT_S – это справочник балансовых счетов. Он регулируется Центральным банком. По нему можно определить к какой главе и к каким разделам относятся счета первого (первые 3 цифры номера счета) и второго (первые 5 цифр номера счета) порядка.
- Таблица DS.FT_POSTING_F – это таблица проводок (операций) в рабочем дне (поле oper_date), которая состоит из двух частей: счет дебета и счет кредита, которая изменяет баланс на сумму проводки 


### Требования к реализации задачи:
- В своей БД создать пользователя / схему «DS».
- Создать в DS-схеме таблицы под загрузку данных из csv-файлов.
- Начало и окончание работы процесса загрузки данных должно логироваться в специальную логовую таблицу. Эту таблицу нужно придумать самостоятельно. По логам должно быть видно дату и время старта и окончания загрузки, так же можете туда добавить любую дополнительную информацию, которую посчитаете нужным.
- После логирования о начале загрузки добавить таймер (паузу) на 5 секунд, чтобы чётко видеть разницу во времени между началом и окончанием загрузки. Из-за небольшого учебного объёма данных – процесс загрузки быстрый;
- Для хранения логов нужно в БД создать отдельного пользователя / схему «LOGS» и создать в этой схеме таблицу для логов;
- Запись в таблицы должна выполняться в режиме «Запись или замена». Поэтому не забудьте определить ключевые поля для возможности обновлять информацию по уже существующим записям;
- Для корректного обновления данных в таблицах детального слоя DS нужно выбрать правильную Update strategy и использовать следующие первичные ключи для таблиц фактов, измерений и справочников (должно быть однозначное уникальное значение, идентифицирующее каждую запись таблицы):

  | Таблица                | Первичный ключ                                                                                                                                                       |
  |------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
  | DS.FT_BALANCE_F        | ON_DATE, ACCOUNT_RK                                                                                                                                                  |
  | DS.FT_POSTING_F        | У данной таблицы нет первичного ключа. Можно считать, что мы всегда в нее будем загружать полный набор данных, поэтому перед каждой загрузкой ее необходимо очищать. |
  | DS.MD_ACCOUNT_D        | DATA_ACTUAL_DATE, ACCOUNT_RK                                                                                                                                         |
  | DS.MD_CURRENCY_D       | CURRENCY_RK, DATA_ACTUAL_DATE                                                                                                                                        |
  | DS.MD_EXCHANGE_RATE_D  | DATA_ACTUAL_DATE, CURRENCY_RK                                                                                                                                        |
  | DS.MD_LEDGER_ACCOUNT_S | LEDGER_ACCOUNT, START_DATE                                                                                                                                           |


## Задание 1.2

После того как детальный слой «DS» успешно наполнен исходными данными из файлов – нужно рассчитать витрины данных в слое «DM»: витрину оборотов по лицевым счетам (DM.DM_ACCOUNT_TURNOVER_F) и витрину остатков по лицевым счетам (DM.DM_ACCOUNT_BALANCE_F). 

### Требования к реализации задачи:
1. Создать схему DM
2. Создать в схеме DM таблицы под будущие витрины (структура и описание этих витрин находится в файле «Структура таблиц.docx»)
3. Начнем с _**витрины оборотов по лицевым счетам**_.
    - Данная витрина содержит информацию по оборотам по лицевым счетам в рамках дня, когда были обороты.
    - Необходимо создать процедуру расчета (ds.fill_account_turnover_f), которая должна иметь один входной параметр – дату расчета (i_OnDate). 
    - Поля должны быть заполнены следующим образом:
       - on_date мы заполняем датой, за которую производим расчет (i_OnDate);
       - account_rk - идентификатор счета, по которому были проводки в дату расчета;
       - credit_amount – сумма проводок (поле DS.FT_POSTING_F.credit_amount) за дату расчета (DS.FT_POSTING_F.oper_date = i_OnDate), где счет участвовал как счет по кредиту (DS.FT_POSTING_F.credit_account_rk);
       - credit_amount_rub – credit_amount из предыдущего пункта, умноженный на курс действующий за эту дату (курс хранится в поле ds.md_exchange_rate_d. reduced_cource). Если информации о курсе нет, то умножаем на единицу.
       - поля debet_amount и debet_amount_rub заполняем аналогично полям credit_amount и credit_amount_rub, только необходимо отбирать проводки, где счет участвовал как счет по дебету (DS.FT_POSTING_F.debet_account_rk) и необходимо брать сумму из поля DS.FT_POSTING_F.debet_amount
    - Если по счету не было проводок в дату расчета, то он не должен попадать в витрину в эту дату. 
    - После создания процедуры рассчитайте данную витрину за каждый день января 2018 года.

4. Далее **_витрина остатков по лицевым счетам_**.
    - Так как остатки за день считаются на основе остатков за предыдущий день, вам необходимо заполнить витрину DM.DM_ACCOUNT_BALANCE_F за 31.12.2017 данными из DS.FT_BALANCE_F. 
    - Поля on_date, account_rk, balance_out заполняются один в один, поле balance_out_rub заполняем как balance_out, умноженный на курс действующий за 31.12.2017. Если информации о курсе нет, то умножаем на единицу.
    - Затем необходимо создать процедуру заполнения витрины остатков по лицевым счетам. Назовите ее ds.fill_account_balance_f. Данная процедура должна иметь один входной параметр – дату расчета (i_OnDate). 
    - Алгоритм заполнения следующий: необходимо взять все счета, действующие за дату расчета (дата расчета лежит между датами актуальности записей в таблице DS.MD_ACCOUNT_D), для этих счетов рассчитываем balance_out по следующему алгоритму:
      - для активных счетов (DS.MD_ACCOUNT_D.char_type = ‘А’): берем остаток в валюте счета за предыдущий день (если его нет, то считаем его равным 0), прибавляем к нему обороты по дебету в валюте счета (DM.DM_ACCOUNT_TURNOVER_F.debet_amount) и вычитаем обороты по кредиту в валюте счета (DM.DM_ACCOUNT_TURNOVER_F.credit_amount) за этот день.
      - для пассивных счетов (DS.MD_ACCOUNT_D.char_type = ‘П’): берем остаток в валюте счета за предыдущий день (если его нет, то считаем его равным 0), вычитаем из него обороты по дебету в валюте счета и прибавляем обороты по кредиту в валюте счета за этот день.
    - Поле balance_out_rub заполняем аналогично полю balance_out, но для расчета берем поля в рублях. 
    - Обратите внимание, что в какие-то дни по счету может не быть оборотов, но остаток по счету мы должны заполнить. 
    - После создания процедуры рассчитайте витрину остатков за каждый день января 2018 года.
5. В процедурах добавьте логирование на свое усмотрение. В качестве таблицы с логами можно использовать таблицу, созданную в задаче 1.1. В логах должна быть информация о том какая витрина рассчитывается, дата и время старта и окончания расчета.
6. Также для возможности перезапускать расчет много раз за одни и те же даты, в процедурах в начале расчета вам необходимо удалять записи за дату расчета.


## Задание 1.3
После того как в предыдущих заданиях вы загрузили необходимую информацию и рассчитали витрины с оборотами и остатками, необходимо произвести расчет 101 формы за январь 2018 года. 101 форма содержит информацию об остатках и оборотах за отчетный период, сгруппированных по балансовым счетам второго порядка.

### Требования к реализации задачи:

1. Создать витрину DM.DM_F101_ROUND_F по форме 101. Структура и описание находится в файле «Структура таблиц.docx».
2. Вам необходимо создать процедуру расчета (назовите ее dm.fill_f101_round_f), которая должна иметь один входной параметр – отчетную дату (i_OnDate).
    - Отчетная дата – это первый день месяца, следующего за отчетным. То есть, если мы хотим рассчитать отчет за январь 2018 года, то должны передать в процедуру 1 февраля 2018 года.
    - В отчет должна попасть информация по всем счетам, действующим в отчетном периоде, группировка в отчете идет по балансовым счетам второго порядка (балансовый счет второго порядка – это первые 5 символов номера счета (DS.MD_ACCOUNT_D.account_number). 
    - Поля витрины должны заполняться следующим образом:
       - FROM_DATE – первый день отчетного периода, TO_DATE – последний день отчетного периода;
       - CHAPTER – глава из справочника балансовых счетов (DS.MD_LEDGER_ACCOUNT_S);
       - LEDGER_ACCOUNT – балансовый счет второго порядка, CHARACTERISTIC – характеристика счета (можно получить из поля DS.MD_ACCOUNT_D.char_type);
       - BALANCE_IN_RUB – сумма остатков в рублях (DM.DM_ACCOUNT_BALANCE_F.balance_out_rub) за день, предшествующий первому дню отчетного периода (если отчет собирается за январь 2018 года, то это 31 декабря 2017 года), для рублевых счетов (рублевые счета, это те, у которых код валюты (поле DS.MD_ACCOUNT_D.currency_code равно 810 или 643));
       - BALANCE_IN_VAL – сумма остатков в рублях за день, предшествующий первому дню отчетного периода для всех счетов, кроме рублевых
       - BALANCE_IN_TOTAL - – сумма остатков в рублях за день, предшествующий первому дню отчетного периода для всех счетов;
       - TURN_DEB_RUB – сумма дебетовых оборотов в рублях (DM.DM_ACCOUNT_TURNOVER_F.debet_amount_rub) за все дни отчетного периода для рублевых счетов
       - TURN_DEB_VAL – сумма дебетовых оборотов в рублях за все дни отчетного периода для всех счетов, кроме рублевых;
       - TURN_DEB_TOTAL – сумма дебетовых оборотов в рублях за все дни отчетного периода для всех счетов
       - TURN_CRE_RUB – сумма кредитовых оборотов в рублях (DM.DM_ACCOUNT_TURNOVER_F.credit_amount_rub) за все дни отчетного периода для рублевых счетов;
       - TURN_CRE_VAL – сумма кредитовых оборотов в рублях за все дни отчетного периода для всех счетов, кроме рублевых;
       - TURN_CRE_TOTAL – сумма кредитовых оборотов в рублях за все дни отчетного периода для всех счетов
       - BALANCE_OUT_RUB – сумма остатков в рублях (DM.DM_ACCOUNT_BALANCE_F.balance_out_rub) за последний день отчетного периода для рублевых счетов;
       - BALANCE_OUT_VAL – сумма остатков в рублях за последний день отчетного периода для всех счетов, кроме рублевых;
       - BALANCE_OUT_TOTAL – сумма остатков в рублях за последний день отчетного периода для всех счетов
3. В процедуре расчета добавьте логирование на свое усмотрение. В качестве таблицы с логами можно использовать таблицу, созданную для предыдущих задач. 

   В логах должна быть информация о том какая витрина рассчитывается, дата и время старта и окончания расчета. 
4. Также для возможности перезапускать расчет много раз за одну и ту же дату, в процедурах в начале расчета вам необходимо удалять записи за дату расчета. 
5. Рассчитайте отчет за январь 2018 года.

## Задание 1.4
Выполнив предыдущие 2 задачи вам удалось рассчитать отчётную форму 101. Теперь необходимо выгрузить эти данные в формате, который бы позволил легко обмениваться ими между отделами. Один из таких форматов – CSV.

### Требования к реализации задачи:

- Напишите скрипт, который позволит выгрузить данные из витрины «dm. dm _f101_round_f» в csv-файл, первой строкой должны быть наименования колонок таблицы.
- Убедитесь, что данные выгружаются в корректном формате и напишите скрипт, который позволит импортировать их обратно в БД. Поменяйте пару значений в выгруженном csv-файле и загрузите его в копию таблицы 101-формы «dm. dm _f101_round_f_v2».
- Постарайтесь покрыть данные процессы простым логированием. Скрипты можно написать на Python / Scala / Java.

# Задание 2

После успешного формирования отчетов, к банку пришел заказчик данных и сообщил, что по имеющимся витринам имеются дефекты. Для того, чтобы заказчик был доволен и мог беспрепятственно пользоваться витринами, необходимо оперативно устранить имеющиеся дефекты.

## Задание 2.1
Имеется витрина dm.client, в которой содержится различная информация по клиентам банка. Заказчик сообщил, что в таблице имеются дубли, которые нужно устранить.

У данной таблицы имеется составной ключ, который состоит из двух полей, по которым можно выявить уникальную строку:
- client_rk – уникальный код клиента
- effective_from_date – дата начала действия записи

Необходимо подготовить запрос, по которому можно обнаружить все дубли в витрине и удалить их.

## Задание 2.2
### Исходные данные
Имеется витрина dm.loan_holiday_info, которая содержит информацию по кредитным каникулам, сделке и продукте, который был предоставлен клиенту в рамках сделки. После проверки качества данных выявилась проблема отсутствия некоторого количества записей в источниках витрины для некоторых периодов эффективности строк.

Источниками для данной витрины являются 3 таблицы:
- rd.deal – информация по сделкам клиентов
- rd.loan_holiday – информация о кредитных каникулах: дата начала, конца, тип кредитных каникул
- rd.product – информация о продуктах банка, которые он предоставляет

При формировании витрины был подготовлен прототип витрины, по которому она собирается, loan_holiday_info_prototype.sql.
Также, источник, из которого были загружены данные сущности на слой rd, предоставил актуальные выгрузки имеющихся у них данных в формате csv.

### Требования к реализации задачи
Необходимо проанализировать витрину, актуальное состояние таблиц-источников витрины и определить, по каким датам эффективности (effective_from_date или effective_to_date) отсутствуют строки и определить, какой способ загрузки новых данных подойдет: полная перегрузка таблицы или загрузка части данных.

Для загрузки данных на слой RD необходимо воспользоваться аналогичным методом загрузки данных из CSV файла в БД, которым Вы пользовались в первом задании. 

После того, как данные будут успешно загружены, необходимо написать процедуру, которая будет повторять шаги из прототипа для выполнения перегрузки данных в витрину.

## Задание 2.3

### Исходные данные
Имеется витрина dm.account_balance_turnover, которая отражает изменение баланса счетов по дням. 
Заказчик очень требователен в части заполнения всех полей этой витрины, например суммы на начало и конец дня, наименование валюты. Во время проверки качества данных обнаружили, что у счетов иногда отличается account_out_sum - сумма на конец одного дня и account_in_sum - сумма на начало следующего.

Витрина dm.account_balance_turnover строится на основе 3 источников:
- rd.account – информация по счетам клиентов
- rd.account_balance – информация с номер счета клиента и суммами на начало и конец дня
- dm.dict_currency – справочник валют

Для витрины имеется прототип account_balance_turnover_prototype.sql.

### Требования к реализации задачи
1. Подготовить запрос, который определит корректное значение поля account_in_sum. Если значения полей account_in_sum одного дня и account_out_sum предыдущего дня отличаются, то корректным выбирается значение account_out_sum предыдущего дня.
2. Подготовить такой же запрос, только проблема теперь в том, что account_in_sum одного дня правильная, а account_out_sum предыдущего дня некорректна. Это означает, что если эти значения отличаются, то корректным значением для account_out_sum предыдущего дня выбирается значение account_in_sum текущего дня.
3. Подготовить запрос, который поправит данные в таблице rd.account_balance используя уже имеющийся запрос из п.1
4. Написать процедуру по аналогии с заданием 2.2 для перезагрузки данных в витрину

В случае, если у Вас возникают какие-то трудности по части данных, необходимо обратиться к аналитику, которые оказывает Вам помощь в устранении данных дефектов (Ваш куратор)
